# Standard library for mshell

# each (list quote: (item --) --)
def each
    over len each-len! # Get total length
    0 each-idx! # index
    (
        [(@each-idx @each-len >=) (break)] if
        over @each-idx nth # Get current item
        over x # Copy over quote, execute
        @each-idx 1 + each-idx! # inc index
    ) loop

    # Drop list and quote, total length, index
    drop drop
end

# map (list quote -- list)
def map
    over len map-len! # Get total length
    0 map-idx! # Index
    [] map-accum! # Accumulator
    (
        [(@map-idx @map-len >=) (break)] if
        over @map-idx nth # Get current item  list quote item
        over x # Copy over quote, execute

        # list quote new-item
        @map-accum append drop # Append to accumulator
        @map-idx 1 + map-idx! # inc index
    ) loop

    # Drop list and quote, push accumulator
    drop drop @map-accum
end

# filter (list quote -- list)
def filter
    over len filter-len! # Get total length
    0 filter-idx! # Index
    [] filter-accum! # Accumulator
    (
        [(@filter-idx @filter-len >=) (break)] if
        over over # list quote list quote
        over @filter-idx nth # Get current item
        dup rot # Get to item item quote
        x # Execute quote
        [() (@filter-accum append filter-accum!) (drop)] if
        drop @filter-idx 1 + filter-idx! # inc index
    ) loop

    # Drop list and quote, push accumulator
    drop drop @filter-accum
end


# .. (-- list[str]), equals kinda looks like lines.
def .. stdin lines end

# tt = Tab separated Table (-- list[list[str]])
def tt .. ("	" split) map end

# wt = Whitespace separated Table (-- list[list[str]])
def wt .. (wsplit) map end

# unlines (list[str] -- str)
def unlines
    [] unlines-accum! # Accumulator
    (
        @unlines-accum append
       "\n" append
       drop
    ) each
    @unlines-accum "" join
end

# map (list quote -- list)
# [seq 1 1000]o; ("Line #" over str + wl) each
# [1 2 3] (2 +) map .s
