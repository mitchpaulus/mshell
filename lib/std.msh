# Standard library for mshell

# type numeric int | float

def each ([T] (T --) --)
    over len each-len! # Get total length
    0 each-idx! # index
    (
        [(@each-idx @each-len >=) (break)] if
        # "Each idx: " w @each-idx w " Each len: " w @each-len wl
        over @each-idx nth # Get current item
        over x  # Copy over quote, execute
        @each-idx 1 + each-idx! # inc index
        # "Each idx: " w @each-idx wl
    ) loop

    # Drop list and quote, total length, index
    drop drop
end

# map (list quote -- list)
def map ([T] (T -- U) -- [U])
    over len map-len! # Get total length
    0 map-idx! # Index
    [] map-accum! # Accumulator
    (
        [(@map-idx @map-len >=) (break)] if
        over @map-idx nth # Get current item  list quote item
        over x # Copy over quote, execute

        # list quote new-item
        @map-accum swap append drop # Append to accumulator
        @map-idx 1 + map-idx! # inc index
    ) loop

    # Drop list and quote, push accumulator
    drop drop @map-accum
end

# filter (list quote -- list)
def filter ([T] (T -- bool) -- [T])
    over len filter-len! # Get total length
    0 filter-idx! # Index
    [] filter-accum! # Accumulator
    (
        [(@filter-idx @filter-len >=) (break)] if
        over over # list quote list quote
        over @filter-idx nth # Get current item
        dup rot # Get to item item quote
        x # Execute quote
        [() (@filter-accum swap append filter-accum!) (drop)] if
        drop @filter-idx 1 + filter-idx! # inc index
    ) loop

    # Drop list and quote, push accumulator
    drop drop @filter-accum
end

# foldl (quote initial list -- result)
def foldl ((T T -- T) T [T] -- T)
    #  quote initial list
    swap foldl-accum!  # Accumulator,
    # quote list
    swap foldl-quote! # Quote
    # list
    (
        @foldl-accum swap # Accumulator item
        @foldl-quote x # Execute quote
        foldl-accum! # Update accumulator
    ) each

    @foldl-accum
end

# sum (list -- value)
def sum ([float] -- float)
    (+) 0 rot foldl
end

# .. (-- list[str]), equals kinda looks like lines.
def .. (-- [str]) stdin lines end

# tt = Tab separated Table (-- list[list[str]])
def tt (-- [[str]]) ..  ("	" split) map end

# wt = Whitespace separated Table (-- [[str*]*])
def wt (-- [[str]]) .. (wsplit) map  end

# wjoin = Whitespace join ([str*] -- str)
def wjoin ([str] -- str) " " join end

# unlines (list[str] -- str)
def unlines ([str] -- str)
    [] unlines-accum! # Accumulator
    (
        @unlines-accum append
       "\n" append
       drop
    ) each
    @unlines-accum "" join
end

# reverse ([T*]|str -- [T*]|str)
def reverse ([T] -- [T])
    dup len 1 - reverse-idx! # Set Idx
    [] # list accum
    (
        [(@reverse-idx 0 <) (break)] if
        over @reverse-idx nth append # Get current item
        @reverse-idx 1 - reverse-idx! # dec index
    ) loop
    nip # Drop original list
end

# abs (int|float -- int|float)
def abs (float -- float)
    [(dup 0 <) (-1 *)] if
end


def tab (-- str) "	" end
def tsplit (str -- [str])  tab split end
def uw ([str] --) unlines w end

def readTsvFile (str -- [[str]])
    readFile lines (tsplit) map end
end
