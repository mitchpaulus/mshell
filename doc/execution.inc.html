<p>
Execution of external commands or binaries is different in <code>mshell</code>. Instead of it being the main syntactical construct, in <code>mshell</code> you build up a list of arguments, and then at a time of your choosing, you execute it.
For example:
</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellSINGLEQUOTESTRING">&#39;my-program&#39;</span> <span class="mshellSINGLEQUOTESTRING">&#39;arg1&#39;</span> <span class="mshellSINGLEQUOTESTRING">&#39;arg2&#39;</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span><span class="mshellEXECUTE">;</span>
<span class="mshellEOF"></span></code>
</pre>

<p>
Often there are different things you want out of your execution,
or you want different behavior depending on the exit code.
<code>mshell</code> gives you full flexibility to decide with concise syntax.
</p>

<p>
To initiate execution, you use one of 3 operators:
</p>

<ul>
  <li><code>;</code>: Execute command, always continue. Don't provide any information on the exit code.</li>
  <li><code>!</code>: Execute command, but stop the running script execution on any non-zero exit code.</li>
  <li><code>?</code>: Execute command, leaving the exit code integer on the stack.</li>
</ul>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellSINGLEQUOTESTRING">&#39;false&#39;</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span><span class="mshellEXECUTE">;</span> <span class="mshellLINECOMMENT"># mshell will continue past this point</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellSINGLEQUOTESTRING">&#39;true&#39;</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span><span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Will execute and continue because of 0 exit code</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellSINGLEQUOTESTRING">&#39;my-command&#39;</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span><span class="mshellQUESTION">?</span> <span class="mshellVARSTORE">exitCode!</span>
<span class="mshellFORMATSTRING">$&#34;Exit code was {@exitCode}&#34;</span> <span class="mshellLITERAL">wl</span>
<span class="mshellEOF"></span></code>
</pre>

<p>
The other choice you often have when executing commands is what to do with the standard output.
Sometimes you will want to redirect it to a file, other times you will want to leave the contents on the stack to process further.
For that, you use the <code>></code>, <code>>></code>, <code>*</code>, and <code>*b</code> operators.
</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`fileToRedirectTo`</span> <span class="mshellGREATERTHAN">&gt;</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Redirects stdout to the file, truncating it.</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`fileToRedirectTo`</span> <span class="mshellSTDAPPEND">&gt;&gt;</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Redirects stdout to the file, appending.</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellASTERISK">*</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Puts all of stdout on the stack as a string.</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellASTERISKBINARY">*b</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Puts all of stdout on the stack as a binary.</span>
</code>
</pre>


<p> You can do similar things with standard error.</p>

<p>
To redirect standard error to a file, use <code>2></code>
<span title="The 2 is the standard error file descriptor; this mirrors typical POSIX shell syntax. It was chosen to be most familiar for those coming from bash/zsh/fish, I might provide a different alias in the future." style="cursor: help;">[?]</span>,
and <code>^</code> instead of <code>*</code>.
</p>

<p>
To redirect both standard output and standard error to the same file, use <code>&amp;></code> (truncate) or <code>&amp;>></code> (append).
This ensures both streams share the same file descriptor, preserving the order of output.
</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`output.log`</span> <span class="mshellSTDOUTANDSTDERRREDIRECT">&amp;></span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Redirects both stdout and stderr to the file, truncating it.</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`output.log`</span> <span class="mshellSTDOUTANDSTDERRAPPEND">&amp;>></span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Redirects both stdout and stderr to the file, appending.</span>
</code>
</pre>

<p>
If you manually use <code>></code> and <code>2></code> with exactly the same path string, mshell will automatically
use a single file descriptor for both streams, avoiding race conditions. However, if the append modes differ
(e.g., <code>></code> and <code>2>></code> to the same file), an error will be raised.
</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`errors.log`</span> <span class="mshellSTDERRREDIRECT">2&gt;</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Redirects stderr to the file, truncating it.</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`errors.log`</span> <span class="mshellSTDERRAPPEND">2&gt;&gt;</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Redirects stderr to the file, appending.</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellCARET">^</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Puts all of stderr on the stack as a string.</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellCARET BINARY">^b</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Puts all of stderr on the stack as a binary.</span>
</code>
</pre>

<p>
If you want to put both standard output and standard error onto the stack, you can do that.
Standard output will always be pushed first, and then standard error.
</p>
<p> So the following are equivalent: </p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellASTERISKBINARY">*b</span> <span class="mshellCARET BINARY">^b</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Order here does not matter</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellCARET BINARY">^b</span> <span class="mshellASTERISKBINARY">*b</span> <span class="mshellBANG">!</span> 
</code>
</pre>

<table>
  <caption>Summary of external command operators</caption>
  <thead>
    <tr> <th>Operator</th> <th>Effect on external commands</th> <th>Notes</th> </tr>
  </thead>
  <tbody>
    <tr> <td><code>;</code></td> <td>Execute and continue.</td> <td>No exit code on the stack.</td> </tr>
    <tr> <td><code>!</code></td> <td>Execute and stop on non-zero exit.</td> <td>Uses the command exit code.</td> </tr>
    <tr> <td><code>?</code></td> <td>Execute and push the exit code.</td> <td>Integer is left on the stack.</td> </tr>
    <tr> <td><code>></code></td> <td>Redirect stdout to a file.</td> <td>Truncates the file.</td> </tr>
    <tr> <td><code>>></code></td> <td>Redirect stdout to a file.</td> <td>Appends to the file.</td> </tr>
    <tr> <td><code>*</code></td> <td>Capture stdout to the stack.</td> <td>As a string.</td> </tr>
    <tr> <td><code>*b</code></td> <td>Capture stdout to the stack.</td> <td>As binary.</td> </tr>
    <tr> <td><code>2></code></td> <td>Redirect stderr to a file.</td> <td>Truncates the file.</td> </tr>
    <tr> <td><code>2>></code></td> <td>Redirect stderr to a file.</td> <td>Appends to the file.</td> </tr>
    <tr> <td><code>&amp;></code></td> <td>Redirect both stdout and stderr to a file.</td> <td>Truncates the file.</td> </tr>
    <tr> <td><code>&amp;>></code></td> <td>Redirect both stdout and stderr to a file.</td> <td>Appends to the file.</td> </tr>
    <tr> <td><code>^</code></td> <td>Capture stderr to the stack.</td> <td>As a string.</td> </tr>
    <tr> <td><code>^b</code></td> <td>Capture stderr to the stack.</td> <td>As binary.</td> </tr>
    <tr> <td><code>&lt;</code></td> <td>Feed stdin from a value.</td> <td>String, path, or binary.</td> </tr>
    <tr> <td><code>&lt;&gt;</code></td> <td>In-place file modification.</td> <td>Reads file to stdin, writes stdout back on success.</td> </tr>
  </tbody>
</table>

<h2 id="quotation-redirection">Redirection on quotations</h2>

<p>
All of the redirection operators above also work on quotations.
This is useful when you want to redirect the output of mshell code that uses <code>wl</code>, <code>wle</code>, or other built-in functions that write to stdout or stderr.
It is also useful when you have many commands that you want to run while appending all the outputs to a single file, without having to put the redirection on each command invocation.
</p>

<pre>
<code><span class="mshellLEFT_PAREN">(</span>
    <span class="mshellSTRING">"Hello from stdout"</span> <span class="mshellLITERAL">wl</span>
    <span class="mshellSTRING">"Hello from stderr"</span> <span class="mshellLITERAL">wle</span>
<span class="mshellRIGHT_PAREN">)</span> <span class="mshellPATH">`output.log`</span> <span class="mshellSTDOUTANDSTDERRREDIRECT">&amp;></span> <span class="mshellEXECUTE">x</span> <span class="mshellLINECOMMENT"># Redirects both stdout and stderr from the quotation to output.log</span>
</code>
</pre>

<pre>
<code><span class="mshellLEFT_PAREN">(</span>
    <span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">echo</span> <span class="mshellSTRING">"Running step 1"</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span><span class="mshellBANG">!</span>
    <span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">echo</span> <span class="mshellSTRING">"Running step 2"</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span><span class="mshellBANG">!</span>
    <span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">echo</span> <span class="mshellSTRING">"Running step 3"</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span><span class="mshellBANG">!</span>
<span class="mshellRIGHT_PAREN">)</span> <span class="mshellPATH">`build.log`</span> <span class="mshellSTDAPPEND">&gt;&gt;</span> <span class="mshellEXECUTE">x</span> <span class="mshellLINECOMMENT"># All command outputs appended to build.log</span>
</code>
</pre>

<h1 id="input-redirection">Input redirection</h1>

<p>
Use <code>&lt;</code> to feed data into stdin. The type of the value on top of the stack determines how the input is provided.
</p>

<p><code>String</code> values are encoded as UTF-8 and streamed as text.</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">wc</span> <span class="mshellLITERAL">-l</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellSTRING">&#34;line 1\nline 2\n&#34;</span> <span class="mshellLESSTHAN">&lt;</span> <span class="mshellEXECUTE">;</span> <span class="mshellLINECOMMENT"># Counts the lines from the provided string</span>
<span class="mshellEOF"></span></code>
</pre>

<p><code>Path</code> values open the referenced file and stream its contents.</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">wc</span> <span class="mshellLITERAL">-l</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`myfile.txt`</span> <span class="mshellLESSTHAN">&lt;</span> <span class="mshellEXECUTE">;</span> <span class="mshellLINECOMMENT"># Equivalent to shell input redirection from a file</span>
<span class="mshellEOF"></span></code>
</pre>

<p><code>Binary</code> values are written directly without any string conversion.</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">md5sum</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`binary_stdin.bin`</span> <span class="mshellLITERAL">readFileBytes</span> <span class="mshellLESSTHAN">&lt;</span> <span class="mshellEXECUTE">;</span> <span class="mshellLINECOMMENT"># Streams raw bytes into the command</span>
<span class="mshellEOF"></span></code>
</pre>

<h1 id="in-place-modification">In-place file modification</h1>

<p>
The <code>&lt;&gt;</code> operator enables in-place file modification. It reads a file's contents,
passes them to the command's stdin, and on successful completion (exit code 0), writes the
command's stdout back to the same file. This is similar to the <code>sponge</code> command
from moreutils.
</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">sort</span> <span class="mshellLITERAL">-u</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`file.txt`</span> <span class="mshellINPLACEREDIRECT">&lt;&gt;</span> <span class="mshellBANG">!</span>
<span class="mshellEOF"></span></code>
</pre>

<p>
This is equivalent to, but safer than:
</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">sort</span> <span class="mshellLITERAL">-u</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`file.txt`</span> <span class="mshellLESSTHAN">&lt;</span> <span class="mshellPATH">`file.txt.tmp`</span> <span class="mshellGREATERTHAN">&gt;</span> <span class="mshellBANG">!</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">mv</span> <span class="mshellLITERAL">file.txt.tmp</span> <span class="mshellLITERAL">file.txt</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellBANG">!</span>
<span class="mshellEOF"></span></code>
</pre>

<h2>Semantics</h2>

<ul>
<li>The file is read when <code>&lt;&gt;</code> is evaluated, capturing its contents at that moment.</li>
<li>If the command exits with code 0 (success), stdout replaces the file contents.</li>
<li>If the command exits with a non-zero code (failure), the original file is preserved unchanged.</li>
<li>File permissions are preserved.</li>
</ul>

<h2>Requirements</h2>

<ul>
<li>Only works with lists (external commands), not quotations.</li>
<li>Requires a <code>Path</code> type (backtick-quoted), not a string.</li>
<li>The file must exist at the time <code>&lt;&gt;</code> is evaluated.</li>
</ul>

<h2>Examples</h2>

<pre>
<code><span class="mshellLINECOMMENT"># Sort a file in place, removing duplicates</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">sort</span> <span class="mshellLITERAL">-u</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`data.txt`</span> <span class="mshellINPLACEREDIRECT">&lt;&gt;</span> <span class="mshellBANG">!</span>

<span class="mshellLINECOMMENT"># Format JSON in place</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">jq</span> <span class="mshellLITERAL">.</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`config.json`</span> <span class="mshellINPLACEREDIRECT">&lt;&gt;</span> <span class="mshellBANG">!</span>

<span class="mshellLINECOMMENT"># Filter lines in place (keep only lines containing "error")</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">grep</span> <span class="mshellLITERAL">error</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`log.txt`</span> <span class="mshellINPLACEREDIRECT">&lt;&gt;</span> <span class="mshellBANG">!</span>

<span class="mshellLINECOMMENT"># Using with ? to check exit code without failing</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">sort</span> <span class="mshellLITERAL">-u</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`file.txt`</span> <span class="mshellINPLACEREDIRECT">&lt;&gt;</span> <span class="mshellQUESTION">?</span>
<span class="mshellINTEGER">0</span> <span class="mshellEQUALS">=</span> <span class="mshellIF">if</span>
    <span class="mshellSTRING">"File sorted successfully"</span> <span class="mshellLITERAL">wl</span>
<span class="mshellELSE">else</span>
    <span class="mshellSTRING">"Sort failed, file unchanged"</span> <span class="mshellLITERAL">wl</span>
<span class="mshellEND">end</span>
<span class="mshellEOF"></span></code>
</pre>

<h1 id="binary-resolution">How mshell finds binaries</h1>

<p>
When executing an external command, <code>mshell</code> resolves the binary name using a two-step process.
First it checks the bin map file for an override, and if none is found it falls back to <code>PATH</code>.
</p>

<p>
The bin map file lives alongside the history files (for example, <code>~/.local/share/msh/msh_bins.txt</code> on Linux/macOS or <code>%LOCALAPPDATA%\mshell\msh_bins.txt</code> on Windows).
Each non-empty line is a tab-separated pair of fields: the binary name and the absolute path to the binary.
Both fields are trimmed, the name must not contain path separators, and the line must contain exactly two fields.
</p>

<pre>
<code>mytool	/usr/local/bin/mytool
another	/home/me/bin/another</code>
</pre>

<p>
To manage the file, use the <code>msh bin</code> subcommands:
</p>

<ul>
  <li><code>msh bin add &lt;path&gt;</code>: add/replace using the file basename and absolute path</li>
  <li><code>msh bin add &lt;name&gt; &lt;path&gt;</code>: add/replace using an explicit name</li>
  <li><code>msh bin remove &lt;name&gt;</code>: remove an entry by name</li>
  <li><code>msh bin list</code>: print the bin map file contents</li>
  <li><code>msh bin path</code>: print the bin map file path</li>
  <li><code>msh bin edit</code>: edit the file in <code>$EDITOR</code></li>
  <li><code>msh bin audit</code>: report invalid or missing entries</li>
  <li><code>msh bin debug &lt;name&gt;</code>: show lookup details for a binary</li>
</ul>
