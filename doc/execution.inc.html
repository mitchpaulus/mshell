<p>
Execution of external commands or binaries is different in <code>mshell</code>. Instead of it being the main syntactical construct, in <code>mshell</code> you build up a list of arguments, and then at a time of your choosing, you execute it.
For example:
</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellSINGLEQUOTESTRING">&#39;my-program&#39;</span> <span class="mshellSINGLEQUOTESTRING">&#39;arg1&#39;</span> <span class="mshellSINGLEQUOTESTRING">&#39;arg2&#39;</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span><span class="mshellEXECUTE">;</span>
<span class="mshellEOF"></span></code>
</pre>

<p>
Often there are different things you want out of your execution,
or you want different behavior depending on the exit code.
<code>mshell</code> gives you full flexibility to decide with concise syntax.
</p>

<p>
To initiate execution, you use one of 3 operators:
</p>

<ul>
  <li><code>;</code>: Execute command, always continue. Don't provide any information on the exit code.</li>
  <li><code>!</code>: Execute command, but stop the running script execution on any non-zero exit code.</li>
  <li><code>?</code>: Execute command, leaving the exit code integer on the stack.</li>
</ul>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellSINGLEQUOTESTRING">&#39;false&#39;</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span><span class="mshellEXECUTE">;</span> <span class="mshellLINECOMMENT"># mshell will continue past this point</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellSINGLEQUOTESTRING">&#39;true&#39;</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span><span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Will execute and continue because of 0 exit code</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellSINGLEQUOTESTRING">&#39;my-command&#39;</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span><span class="mshellQUESTION">?</span> <span class="mshellVARSTORE">exitCode!</span>
<span class="mshellFORMATSTRING">$&#34;Exit code was {@exitCode}&#34;</span> <span class="mshellLITERAL">wl</span>
<span class="mshellEOF"></span></code>
</pre>

<p>
The other choice you often have when executing commands is what to do with the standard output.
Sometimes you will want to redirect it to a file, other times you will want to leave the contents on the stack to process further.
For that, you use the <code>></code>, <code>>></code>, <code>*</code>, and <code>*b</code> operators.
</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`fileToRedirectTo`</span> <span class="mshellGREATERTHAN">&gt;</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Redirects stdout to the file, truncating it.</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`fileToRedirectTo`</span> <span class="mshellSTDAPPEND">&gt;&gt;</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Redirects stdout to the file, appending.</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellASTERISK">*</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Puts all of stdout on the stack as a string.</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellASTERISKBINARY">*b</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Puts all of stdout on the stack as a binary.</span>
</code>
</pre>


<p> You can do similar things with standard error.</p>

<p>
To redirect standard error to a file, use <code>2></code>
<span title="The 2 is the standard error file descriptor; this mirrors typical POSIX shell syntax. It was chosen to be most familiar for those coming from bash/zsh/fish, I might provide a different alias in the future." style="cursor: help;">[?]</span>,
and <code>^</code> instead of <code>*</code>.

</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`errors.log`</span> <span class="mshellSTDERRREDIRECT">2&gt;</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Redirects stderr to the file, truncating it.</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`errors.log`</span> <span class="mshellSTDERRAPPEND">2&gt;&gt;</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Redirects stderr to the file, appending.</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellCARET">^</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Puts all of stderr on the stack as a string.</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellCARET BINARY">^b</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Puts all of stderr on the stack as a binary.</span>
</code>
</pre>

<p>
If you want to put both standard output and standard error onto the stack, you can do that.
Standard output will always be pushed first, and then standard error.
</p>
<p> So the following are equivalent: </p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellASTERISKBINARY">*b</span> <span class="mshellCARET BINARY">^b</span> <span class="mshellBANG">!</span> <span class="mshellLINECOMMENT"># Order here does not matter</span>
<span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">yourCommand</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellCARET BINARY">^b</span> <span class="mshellASTERISKBINARY">*b</span> <span class="mshellBANG">!</span> 
</code>
</pre>

<table>
  <caption>Summary of external command operators</caption>
  <thead>
    <tr> <th>Operator</th> <th>Effect on external commands</th> <th>Notes</th> </tr>
  </thead>
  <tbody>
    <tr> <td><code>;</code></td> <td>Execute and continue.</td> <td>No exit code on the stack.</td> </tr>
    <tr> <td><code>!</code></td> <td>Execute and stop on non-zero exit.</td> <td>Uses the command exit code.</td> </tr>
    <tr> <td><code>?</code></td> <td>Execute and push the exit code.</td> <td>Integer is left on the stack.</td> </tr>
    <tr> <td><code>></code></td> <td>Redirect stdout to a file.</td> <td>Truncates the file.</td> </tr>
    <tr> <td><code>>></code></td> <td>Redirect stdout to a file.</td> <td>Appends to the file.</td> </tr>
    <tr> <td><code>*</code></td> <td>Capture stdout to the stack.</td> <td>As a string.</td> </tr>
    <tr> <td><code>*b</code></td> <td>Capture stdout to the stack.</td> <td>As binary.</td> </tr>
    <tr> <td><code>2></code></td> <td>Redirect stderr to a file.</td> <td>Truncates the file.</td> </tr>
    <tr> <td><code>2>></code></td> <td>Redirect stderr to a file.</td> <td>Appends to the file.</td> </tr>
    <tr> <td><code>^</code></td> <td>Capture stderr to the stack.</td> <td>As a string.</td> </tr>
    <tr> <td><code>^b</code></td> <td>Capture stderr to the stack.</td> <td>As binary.</td> </tr>
    <tr> <td><code>&lt;</code></td> <td>Feed stdin from a value.</td> <td>String, path, or binary.</td> </tr>
  </tbody>
</table>

<h1 id="input-redirection">Input redirection</h1>

<p>
Use <code>&lt;</code> to feed data into stdin. The type of the value on top of the stack determines how the input is provided.
</p>

<p><code>String</code> values are encoded as UTF-8 and streamed as text.</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">wc</span> <span class="mshellLITERAL">-l</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellSTRING">&#34;line 1\nline 2\n&#34;</span> <span class="mshellLESSTHAN">&lt;</span> <span class="mshellEXECUTE">;</span> <span class="mshellLINECOMMENT"># Counts the lines from the provided string</span>
<span class="mshellEOF"></span></code>
</pre>

<p><code>Path</code> values open the referenced file and stream its contents.</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">wc</span> <span class="mshellLITERAL">-l</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`myfile.txt`</span> <span class="mshellLESSTHAN">&lt;</span> <span class="mshellEXECUTE">;</span> <span class="mshellLINECOMMENT"># Equivalent to shell input redirection from a file</span>
<span class="mshellEOF"></span></code>
</pre>

<p><code>Binary</code> values are written directly without any string conversion.</p>

<pre>
<code><span class="mshellLEFT_SQUARE_BRACKET">[</span><span class="mshellLITERAL">md5sum</span><span class="mshellRIGHT_SQUARE_BRACKET">]</span> <span class="mshellPATH">`binary_stdin.bin`</span> <span class="mshellLITERAL">readFileBytes</span> <span class="mshellLESSTHAN">&lt;</span> <span class="mshellEXECUTE">;</span> <span class="mshellLINECOMMENT"># Streams raw bytes into the command</span>
<span class="mshellEOF"></span></code>
</pre>

<h1 id="binary-resolution">How mshell finds binaries</h1>

<p>
When executing an external command, <code>mshell</code> resolves the binary name using a two-step process.
First it checks the bin map file for an override, and if none is found it falls back to <code>PATH</code>.
</p>

<p>
The bin map file lives alongside the history files (for example, <code>~/.local/share/msh/msh_bins.txt</code> on Linux/macOS or <code>%LOCALAPPDATA%\mshell\msh_bins.txt</code> on Windows).
Each non-empty line is a tab-separated pair of fields: the binary name and the absolute path to the binary.
Both fields are trimmed, the name must not contain path separators, and the line must contain exactly two fields.
</p>

<pre>
<code>mytool	/usr/local/bin/mytool
another	/home/me/bin/another</code>
</pre>

<p>
To manage the file, use the <code>msh bin</code> subcommands:
</p>

<ul>
  <li><code>msh bin add &lt;path&gt;</code>: add/replace using the file basename and absolute path</li>
  <li><code>msh bin add &lt;name&gt; &lt;path&gt;</code>: add/replace using an explicit name</li>
  <li><code>msh bin remove &lt;name&gt;</code>: remove an entry by name</li>
  <li><code>msh bin list</code>: print the bin map file contents</li>
  <li><code>msh bin path</code>: print the bin map file path</li>
  <li><code>msh bin edit</code>: edit the file in <code>$EDITOR</code></li>
  <li><code>msh bin audit</code>: report invalid or missing entries</li>
  <li><code>msh bin debug &lt;name&gt;</code>: show lookup details for a binary</li>
</ul>
